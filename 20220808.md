# 1 프로그래밍

## 1.1 프로그래밍이란?

프로그래밍이란 0과 1밖에 알지 못하는 기계가 실행할 수 있을 정도로 정확하고 상세하게 요구사항을 설명하는 작업. 이때 필요한것이 컴퓨팅적 사고.

## 1.2 프로그래밍 언어

컴퓨터에 명령을 내리기 위해 프로그래밍 언어를 사용해 작성한 후, 컴파일러 혹은 인터프리터로 번역하여 기계어로 바꿔 컴퓨터에게 전달.

프로그래밍 언어는 구문과 의미의 조합으로 표현된다.

## 1.3 구문과 의미

해결 방안의 구체적 구현물은 문법에 부합해야 하는 것은 물론이고 수행하고자 하는 바를 정확히 수행하는 것, 즉 요구사항이 실현(문제가 해결)되어야 의미가 있다.

<aside>
💡 결국 프로그래밍은 요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것.

</aside>

# 2 자바스크립트란?

## 2.1 자바스크립트의 탄생

자바스크립트는 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어로 만들어짐

## 2.2 자바스크립트의 표준화

JScript와 자바스크립트가 경쟁하는 과정 속에서 브라우저에 따라 웹페이지가 정상적으로 동작하지 않는 크로스 브라우징 이슈가 발생.

이에 자바스크립트의 파편화를 방지하고 모든 브라우저에서 정상적으로 동작하는 표준화된 자바스크립트의 필요성이 대두되기 시작했고 ECMAScript가 나왔다.

## 2.3 자바스크립트 성장의 역사

초창기 자바스크립트는 보조적인 기능을 수행하기 위해 사용. 대부분의 로직은 웹서버에서 실행. 브라우저는 서버로부터 전달받은 HTML과 CSS를 단순히 렌더링하는 수준.

### 2.3.1 Ajax

자바스크립트를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신 기능인 Ajax가 XMLHttpRequest라는 이름으로 등장.

이전의 웹페이지는 완전한 HTTML 코드를 서버로부터 전송받아 웹페이지 전체를 렌더링하는 방식으로 동작. 그래서 화면이 전환되면 새로운 HTML을 전송받아 웹페이지 전체를 처음부터 다시 렌더링

하지만 Ajax의 등장으로 서버로부터 필요한 데이터만 전송받아 변경해야 하는 부분만 렌더링하는이 가능해짐. 

### 2.3.2 jQuery

jQuery의 등장으로 DOM을 더욱 쉽게 제어할 수 있게 되었다.

### 2.3.3 V8 자바스크립트 엔진

V8 자바스크립트 엔진의 등장으로 자바스크립트는 데스크톱 애플리케이션과 유사한 사용자 경함을 제공할 수 있는 웹 애플리케이션 프로그래밍 언어로 장착

그리하여 웹 서버에서 수행되던 로직들이 클라이언트(브라우저)로 이동.

### 2.3.4 Node.js

Node.js는 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경. 즉, 브라우저의 자바스크립트 엔진에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서도 동작할 수 있도록 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경.

Node.js는 비동기 I/O를 지원하며 단일 스레드 이벤트 루프 기반으로 동작함으로써 요청 처리 성능이 좋다. 따라서 실시간으로 데이터를 처리하기 위해 I/O가 빈번하게 발생하는 SPA에 적합.

### 2.3.5 SPA 프레임워크

Coponent based development 방법론을 기반으로 하는 SPA 가 대중화되면서 Angular, React, Vue.js 등 다양한 SPA 프레임워크/라이브러리가 인기를 끌고 있다.

## 2.4 자바스크립트와 ECMAScript

ECMAScript는 프로그래밍 언어의 값, 타입, 객체와 프로퍼티, 함수, 표준 빌트인 객체 등 핵심 문법을 규정.

자바스크립트는 기본 뼈대를 이루는 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이드 Web API, 즉 DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web Worker 등을 아우르는 개념.

클라이언트 사이드 Web API의 자세한 내용은 MDN web docs의 Web API 페이지를 참고

## 2.5 자바스크립트의 특징

웹 브라우저에서 동작하는 유일한 프로그래밍 언어.

자바스크립트는 인터프리터 언어. 대부분의 모던 자바스크립트 엔진 (V8, SpiderMonkey 등)은 인터프리터와 컴파일러의 장점을 결합해 처리속도가 느린 인터프리터의 단점을 해결

### 인터프리터 언어 vs 컴파일러 언어

컴파일러 언어

- 코드가 실행되기 전 단계인 컴파일 타임에 소스코드 전체를 한번에 머신 코드로 변환 후 실행한다.
- 실행 파일을 생성한다.
- 컴파일 단계와 실생 단계가 분리되어 있다. 명시적인 컴파일 단계를 거치고, 명시적으로 실행 파일을 실행한다.
- 실행에 앞서 컴파일은 단 한번 수행된다.
- 컴파일과 실행 단계가 분리되어 있으므로 코드 실행 속도가 빠르다.

인터프리터 언어

- 코드가 실행되는 단계인 런타임에 문 단위로 한 줄씩 중간 코드인 바이트코드로 변환한 후 실행한다.
- 실행 파일을 생성하지 않는다.
- 인터프리트 단계외 실행 단계가 분리되어있지 않다. 인터프리터는 한 줄씩 바이트코드로 변환하고 즉시 실행한다.
- 코드가 실행될 때마다 인터프리트 과정이 반복 수행된다.
- 인터프리트 단계와 실행 단계가 분리되어 있지 않고 반복 수행되므로 코드 실행 속도가 비교적 느리다.

하지만 대부분의 모던 브라우저에서 사용되는 인터프리터는 전통적인 컴파일러 언어 처럼 명시적인 컴파일 단계를 거치지는 않지만 복잡한 과정을 겨치며 일부 소스코드를 컴파일하고 실행.

이를 통해 인터프리터 언어의 장점인 동적 기능 지원을 살리면서 실행 속도가 느리다는 단점을 극복.

하지만 자바스크립트는 런타임에 컴파일되며 실행 파일이 생성되지 않고 인터프리터의 도움 없이 실행할 수 없기 때문에 컴파이러 언어라고 할 수 없음

자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어

자바스크립트는 클래스 기반 객체지향 언어보다 효율적이며 강력한 프로토타입 기반의 객체지향 언어

## 2.6 ES6 브라우저 지원 현황

IE를 제외한 모던 브라우저의 ES6 지원 비율은 96 ~ 99%로 거의 100%에 육박하지만 IE나 구형 브라우저는 ES6를 대부분 지원하지 않는다.

따라서 브라우저에서 아직 지원하지 않는 최신 기능을 사용하거나 IE나 구형 브라우저를 고려해야하는 상황이라면 바벨같은 트랜스파일러를 사용.

# 3 자바스크립트 개발 환경과 실행 방법

## 3.1 자바스크립트 실행 환경

자바스크립트는 브라우저 환경 또는 Node.js 환경에서 실행할 수 있다.

하지만 브라우저와 Node.js 모두 자바스크립트의 코어인 ECMAScript를 실행할 수 있지만 브라우저와 Node.js에서 ECMAScript 이외에 추가로 제공하는 기능은 호환되지 않는다.

브라우저는 ECMAScript 와 DOM, BOM, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Components, Web Worker 같은 클라이언트 사이드 Web API를 지원한다. Node.js는 클라이언트 사이드 Web API를 지원하지 않고 ECMAScript와 Node.js 고유의 API를 지원한다.

## 3.2 웹 브라우저

구글 크롬으로 진행. 크롬 브라우저의 V8 자바스크립트 엔진은 Node.js에서도 사용.

### 3.2.1 개발자 도구

개발자 도구는 웹 개발에 유용한 다양한 기능을 제공한다. 자주 사용하는 개발자 도구의 기능은 다음과 같다.

- Elements
    
    로딩된 퓁패이지의 DOM과 CSS를 편집해서 렌더링된 뷰를 확인해 볼 수 있다.
    
- Console
    
    로딩된 웹페이지의 에러를 확인하거나 자바스크립트 소스코드에 작성한 console.log 메서드의 실행 결과를 확인할 수 있다.
    
- Source
    
    로딩된 웹페이지의 자바스크립트 코드를 디버깅할 수 있다.
    
- Network
    
    로딩된 웹페이지에 관련된 네트워크 요청 정보와 성능을 확인할 수 있다.
    
- Application
    
    웹 스토리지, 세션, 쿠키를 확인하고 관리할 수 있다.
    

### 3.2.2 콘솔

개발자 도구의 콘솔은 자바스크립트 코드에서 에러가 발생해 애플리케이션이 정상적으로 동작하지 않을 때 가장 우선적으로 살펴봐야 할 곳.

에러가 아니더라도 구현 단계에서 디버깅을 실행하는 것보다 간편하게 코드의 실행 결과를 확인하면서 개발을 진행하기 위해 console.log 메서드를 사용하는 경우가 많다.

콘솔은 자바스크립트 코드를 직접 입력해 그 결과를 확인할 수 있는 REPL(Read Eval Print Loop: 입력 수행 출력 반복) 환경으로 사용할 수도 있다.

### 3.2.3 브라우저에서 자바스크립트 실행

브라우저는 HTML 파일을 로드하면 script 태그에 포함된 자바스크립트 코드를 실행한다. 만약 자바스크립트 코드 내에서 console.log 메서드가 호출되었다면 콘솔에 실행 결과가 출력될 것이다.

```html
<!DOCTYPE html>
<html lang="ko-KR">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
</head>
<body>
  <div id="counter">0</div>
  <button id="increase">+</button>
  <button id="decrease">-</button>
  <script>
    const $counter = document.getElementById('counter-x');
    const $increase = document.getElementById('increase');
    const $decrease = document.getElementById('decrease');

    let num = 0;
    const render = function () { $counter.innerHTML = num; }

    $increase.onclick = function () {
      num++;
      console.log('increase 버튼 클릭', num);
      render();
    };

    $decrease.onclick = function () {
      num--;
      console.log('decrease 버튼 클릭', num);
      render();
    };
  </script>
</body>
</html>
```

‘+’, ‘-’ 버튼을 클릭하면 에러가 발생.

![20220808103047.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/03836939-e458-4b6d-b0f1-68a4f6a68cc8/20220808103047.png)

에러가 발생했으나 일부 실행됨

### 3.2.4 디버깅

에러 정보의 오른쪽 에러 발생 위치를 나타내는 링크를 클릭하면 자바스크립트 코드를 디버깅할 수 있는 Sources 패널로 이동

![20220808103543.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/05c94710-640f-4b41-9bd7-81af7cabfd83/20220808103543.png)

에러가 발생한 위치에 빨간 밑줄이 표시되고, 그 위에 마우스를 올려보면 에러 정보가 표시된다.

![20220808104310.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/86e22cad-c22f-4713-9d0e-4511a43f7e6b/20220808104310.png)

19번째 줄의 $counter에 마우스 커서를 욜려보면 $counter 변수의 값을 확인할 수 있다. 현재 $counter의 값은 null이다. 그 원인은  $counter 변수에 값을 할당할 때 HTML 요소의 아이디를 counter-x로 잘못 지정한 탓이다.  

다시 소스코드로 돌아가 counter-x 를 counter로 수정하면 에러가 제거됨.

이처럼 디버깅은 먼제 에러 메시지를 확인하고 에러가 발생한 원인을 제거하는 것이다.

## 3.3 Node.js

프로젝트의 규모가 커짐에 따라 React, Angular, Lodash 같은 프레임워크 또는 라이브러리를 도입하거나 Babel, Webpack, ESLint 등 여러 가지 도구를 사용할 필요가 있다. 이때 Node.js와 npm이 필요하다.

### 3.3.1 Node.js와 npm 소개

Node.js는 크롬 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경. 즉, 브라우저에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서 동작시킬 수 있는 자바스크립트 실행 환경이 Node.js다.

npm은 자바스크립트 패키지 매니저다. Node.js에서 사용할 수 있는 모듈들을 패키지화해서 모아둔 저장소 역할과 패키지 설치 및 관리를 위한 CLI를 제공한다.

### 3.3.2 Node.js 설치

Node.js 웹사이트에 접속하면 두 개의 다운로드 버튼이 있음.

LTS 버전은 장기적으로 안정된 지원이 보장. 반면 Current 버전은 최신 기능을 제공하지만 업데이트가 발생하는 버전으로 안정적이지 않을 수 있다.

- 설치위치
    
    윈도우: C:\Program Files\nodejs\node.exe
    
    macOS: /usr/local/bin/node
    

설치가 완료되면 터미널에서 Node.js와 npm의 버전을 출력해 설치되었는지 확인

![20220808110108.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1fe2cbe3-893c-497c-9f85-6b3fe958bc43/20220808110108.png)

### 3.3.3 Node.js REPL

Node.js가 제공하는 REPL을 사용하면 간단한 자바스크립트 코드를 실행해 결과를 확인해 볼 수 있다.

![20220808111124.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/23650ee9-4704-45bd-9433-4052fcc6a933/20220808111124.png)

프롬프트가 >로 변경되면 자바스크립트 코드를 실행해 볼 수 있다.

![20220808111304.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e132a5a6-3ea1-4f2e-b634-6f8cb674405a/20220808111304.png)

자바스크립트 파일을 실행하려면 node 명령어 뒤에 파일 이름을 입력한다. 파일 확장자 `.js`는 생략해도 된다.

```bash
$ node index.js
```

Ctrl + C 키를 두 번 입력하면 Node.js REPL이 종료된다. 

## 3.4 비주얼 스튜디오 코드

### 3.4.1 비주얼 스튜디오 코드 설치

브라우저의 콘솔 또는 Node.js의 REPL에서 자바스크립트 코드를 실행할 수 있지만 애플리케이션을 개발하는 단계에서 사용하기에는 부족함이 많다. 코드 에디터를 사용하면 코드 자동 완성, 문법 오류 감지, 디버깅, Git 연동 등 강력하고 편리한 기능을 활용할 수 있다. 여기에서는 VS Code를 사용

### 3.4.2 내장 터미널

프로젝트 폴더를 생성하고 자바스크립트 파일을 생성

![20220808112508.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e63ba113-0313-4716-8fd3-784a4e618ca8/20220808112508.png)

내장 터미널이 열리고 프롬프트가 나타나면 다음과 같은 Node.js 명령어로 자바스크립트 파일을 실행할 수 있다.

![20220808112514.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3466dcb2-d134-4202-adc4-47c75d2221bd/20220808112514.png)

 

### 3.4.3 Code Runner 확장 플러그인

VS Code에서는 확장 플러그인 저장소인 “마켓플레이스”를 통해 다양한 확장 플러그인을 다운로드해서 설치할 수 있다.

Code Runner 확장 플러그인을 사용하면 VS Code의 내장 터미널에서 단축키를 사용해 자바스크립트를 비롯해 다양한 프로그래밍 언어로 구현된 소스코드를 실행할 수 있다.

![20220808113019.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a3d547f9-432f-447f-87b7-8c46ecb37a9d/20220808113019.png)

Code Runner 확장 플러그인에서는 다음과 같은 단축키를 사용해 현재 표시 중인 자바스크립트 파일을 실행할 수 있다.

윈도우 : Ctrl + Alt + N

![20220808125155.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/08776808-cb2b-4b1f-a461-e51aa814bf69/20220808125155.png)

밑의 소스코드를 실행하면 “ReferenceError: alert is not defined” 라는 에러가 발생한다.

alert 함수는 브라우저에서만 동작하는 클라이언트 사이트 Web API다. 즉, alert함수는 브라우저 환경에서만 유효하다.

Code Runner 확장 플러그인은 Node.js 환경을 사용해 자바스크립트를 실행한다. 그래서 클라이언트 사이트 Web API인 alert함수를 Node.js 환경에서는 알 수 없기 때문에 에러가 발생한 것.

```jsx
const arr = [1,2,3];
arr.forEach(alert)
```

### 3.4.4 Live Server 확장 프러그인

```html
<!DOCTYPE html>
<html lang="ko-KR">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
</head>
<body>
  <script src="./03_4_2.js"></script>
</body>
</html>
```

위 예제를 브라우저에서 실행하려면 개발자 도구의 콘솔에서 실행하거나 자바스크립트 코드를 HTML에 삽입한 다음 HTML 파일을 브라우저에서 열어야한다.

Live Server라는 확장 플러그인을 이용하면 소스코드를 수정할 때마다 수정 사항을 브라우저에 자동으로 반영해주기 때문에 편리. Live Server 확장 플러그인이 설치되면 화면 아래에 Go Live라는 버튼이 생기는데 클릭하면 가상 서버가 가동되어 브라우저에 HTML 파일이 자동 로딩됨. 이후 소스코드를 수정하면 수정 사항이 가상 서버에 자동으로 반영된다.

# 4 변수

## 4.1 변수란 무엇인가? 왜 필요한가?

자바스크립트 엔진이 위 자바스크립트 코드를 계산(평가 evaluate)하려면 먼저 10, 20, + 라는 기호 (리터럴 literal과 연산자 operator)의 의미를 알고 있어야 하며, 10 + 20이라는 식(표현식 expression)의 의미도 해석(파싱parsing)할 수 있어야 한다.

그리고 10 + 20 이라는 식의 의미를 해석하면 + 연산을 수항하기 위해 먼저 연산자 좌변과 우변의 피연산자operand를 기억한다. 

컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다.

메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체다. 메모리 셀 하나의 크기는 1바이트(8비트)이며, 컴퓨터는 메모리 셀의 크기, 즉 1바이트 단위로 데이터를 저장write하거나 읽어read들인다.

![KakaoTalk_20220808_133238906.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f5d762f7-57c5-40b8-851e-ffb937c65bdb/KakaoTalk_20220808_133238906.jpg)

각 셀은 고유의 메모리 주소를 갖는다. 메모리 주소는 메모리 공간의 위치를 나타내며, 0부터 시작해서 메모리의 크기만큼 정수로 표현된다. 

컴퓨터는 모든 데이터를 2진수로 처리한다.

위 예제의 숫자 값 10과 20은 메모리 상의 임의의 위치(메모리 주소)에 기억(저장)되고 CPU는 이값을 읽어 연산을 수행. 연산 결과로 생성된 숫자 값 30도 메모리 상의 임의의 위치에 저장된다. 

![KakaoTalk_20220808_133238906_01.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cc4f3a19-4d34-49ab-aafd-f9986fd3c02c/KakaoTalk_20220808_133238906_01.jpg)

성공적으로 연산이 끝나고 연산 결과도 메모리에 저장되었지만 CPU가 연산해서 만들어낸 숫자 값 30을 재사용할 수 없다.

연산 결과를 재사용하고 싶으면 메모리 주소를 통해 연산 결과가 저장된 메모리 공간에 직접 접근하는 것 외에는 방법이 없다.

하지만 메모리 주소를 통해 값에 직접 접근하는 것은 치명적 오류를 발생시킬 가능성이 매우 놓기 때문에 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않음.

프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메코니즘을 제공.

변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.

간단히 말하자면 변수는 값의 위치를 가리키는 상징적인 이름. 

상징적 이름인 변수는 프로그래밍 언어의 컴파이러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행된다.

```jsx
var result = 10 + 20;
```

연산을 통해 생성된 값은 메모리 공간에 저장된다. 이때 메모리 공간에 저장된 값 30을 다시 읽어 들여 재사용할 수 있도록 값이 저장된 메모리 공간에 상징적인 이름을 붙인 것이 바로 변수.

![KakaoTalk_20220808_133238906_02.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e7e6288a-bbc2-4634-b1d2-eed0dd9e989a/KakaoTalk_20220808_133238906_02.jpg)

메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 변수 이름(또는 변수명). 변수에 저장된 값을 변수 값. 변수에 값을 저장하는 것을 할당. 변수에 저장된 값을 읽어 들이는 것을 참조

## 4.2 식별자

식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.

식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보도 메모리에 저장되어야함.

이처럼 식별자는 값이 아니라 메모리 주소를 기억하고 있다. 즉, 식별자는 메모리 주소에 붙인 이름

![KakaoTalk_20220808_135509222.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1867afdb-7a1e-492e-86a1-c9becbca5d7e/KakaoTalk_20220808_135509222.jpg)

식별자라는 용어는 변수 이름에만 국한해서 사용하지 않는다. 예를 들어, 변수, 함수, 클래스 등의 이름은 모두 식별자다.

즉,  메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 부른다.

변수, 함수, 클래스 등의 이름과 같은 식별자는 네이밍 규칙을 준수해야 하며, 선언에 의해 자바스크립트 엔진에 식별자의 존재를 알린다. 변수를 선언하는 방법을 살펴보자.

## 4.3 변수 선언

변수 선언이란 변수를 생성하는 것. 자세히 말하면 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것이다. 

변수 선언에 의해 확보된 메모리 공간은 확보가 해제되기 전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전하게 사용할 수 있다.

변수를 사용하려면 반드시 선언이 필요하다. 변수를 선언할 때는 var, let, const 키워드를 사용한다. 

var 키워드는 뒤에 오는 변수 이름으로 새로운 변수를 선언할 것을 지시하는 키워드다.

```jsx
var score;
```

위 변수 선언문은 다음과 같이 변수 이름을 등록하고 값을 저장할 메모리 공간을 확보한다.

![KakaoTalk_20220808_141455952.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/535aaf1b-6e4b-42d2-93e7-3f6a20cb2a6c/KakaoTalk_20220808_141455952.jpg)

자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행한다.

- 선언단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
- 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.

var 키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행된다. var score;는 선언 단계를 통해 변수 이름 score를 등록하고, 초기화 단계를 통해 score 변수에 암묵적으로 undefined를 할당해 초기화한다.

만약 초기화 단계를 거치지 않으면 확보된 메모리 공간에 이전에 다른 애플리케이션이 사용했던 쓰레기 값이 남아있을 수 있다. 따라서 메모리 공간을 확보한 다음, 값을 할당하지 않은 상태에서 곧바로 변수 값을 참조하면 쓰레기 값이 나올 수 있다. var 키워드는 암묵적으로 초기화를 수행하므로 이러한 위험으로부터 안전하다.

식별자를 사용하려면 반드시 선언이 필요하다. 만약 선언하지 않은 식별자에 접근하면 Reference(참조 에러)가 발행한다. 참조에러는 식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러

![20220808142916.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8a4420ba-ee50-4f3c-8371-567ec5263d22/20220808142916.png)

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

```jsx
console.log(score);  // undefined
var score;  // 변수 선언문 
```

자바스크립트는 인터프리터에 의해 한 줄씩 순차적으로 실행되므로 console.log(score); 가 가장 먼저 실행되고 순차적으로 다음 줄에 있는 코드를 실행한다. 따라서 console.log(score);가 실행되는 시점에는 아직 score 변수의 선언이 실행되지 않았으므로 참조에러가 발생할 것처럼 보이지만 undefined가 출력된다.

그 이유는 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.

자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기 앞서 먼저 소스코드의 평가 과정을 거치면서 소스코드를 실행하기 위한 준비를 한다. 이때 소스코드 평가 과정에서 변수 선언을 포함한 모든 선언문 (변수 선언문, 함수 선언문 등)을 소스코드에서 찾아내 먼저 실행한다. 그리고 평가 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.

즉, 자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행. 따라서 변수 선언이 소스코드의 어디에 위치하는지와 상관없이 어디서든지 변수를 참조할 수 있음

이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라 한다.

변수 선언뿐 아니라 var, let, const, function, function*, class 키워드를 사용해서 선언하는 모든 식별자(변수, 함수, 클래스 등)는 호이스팅된다. 모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문.

## 4.5 값의 할당

변수에 값을 할당(대입, 저장)할 때는 할당 연산자 =를 사용한다. 할당 연산자는 우변의 값을 좌변의 변수에 할당한다.

```jsx
var score;  // 변수 선언
score = 80;  // 값의 할당
```

변수 선언과 값의 할당을 하나의 문 statement으로 단축 표현할 수도 있다.

```jsx
var score = 80; // 변수 선언과 값의 할당
```

이때 주의할 점은 변수 선언과 값의 할당의 실행 시점이 다르다는 것이다. 변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.

```jsx
console.log(score); // undefined

var score;  // 1 변수 선언
score = 80;  // 2 값의 할당

console.log(score);  // 80
```

변수선언(1)은 런타임 이전에 먼저 실행되고 값의 할당(2)은 런타임에 실행된다. 따라서 score 변수에 값을 할당하는 시점(2)에는 이미 변수 선언이 완료된 상태이며, 이미 undefined로 초기화되어 있다. 따라서 score 변수에 값을 할당하면 score변수의 값은 undefined에서 새롭게 할당한 숫자 값 80으로 재할당된다.

```jsx
console.log(score); // undefined

var score = 80;  // 변수 선언과 값의 할당

console.log(score);  // 80
```

변수의 선언과 값의 할당을 하나의 문장으로 단축 표현해도 자바스크립트 엔진은 변수의 선언과 값의 할당을 2개의 문으로 나누어 각각 실행한다.

![KakaoTalk_20220808_150256815.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dbf56440-01b0-4eca-962e-540ffbb66ebb/KakaoTalk_20220808_150256815.jpg)

변수에 값을 할당할 때는 이전 값 undefined가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값 80을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 할당 값 80을 저장.

```jsx
console.log(score);

score = 80;
var score;

console.log(score)
```

런타임 이전에 score가 선언과 동시에 undefined로 초기화되고 런타임에 첫번째 콘솔에서는 이미 undefined로 초기화되어 있기 때문에 undefined가 출력되고 score에 80이 재할당 됨. 그리고 마지막 콘솔에서 80이 출력

## 4.6 값의 재할당

재할당이란 이미 값이 할당되어 있는 변수에 새로운 값을 또 다시 할당하는 것을 말한다.

```jsx
var score = 80;  // 변수 선언과 값의 할당
score = 90;  // 값의 재할당
```

var 키워드로 선언한 변수는 값을 재할당할 수 있다.

만약 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수constant라 한다. 상수는 한번 정해지면 변하지 않는 값.

![KakaoTalk_20220808_152342754.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/26adfc71-3650-488d-9f70-1dbc1407b077/KakaoTalk_20220808_152342754.jpg)

변수에 값을 재할당하면 score 변수의 값은 90으로 변경되는데 이전 값 80이 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 재할당 값 90을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그 메모리 공간에 숫자 값 90을 저장한다.

undefined와 80은 어떤 변수도 값으로 갖고 있지 않다. 다시 말해, 어떤 식별자와도 연결되어 있지 않다. 이것은 undefined와 80이 더 이상 필요하지 않다는 것을 의미한다. 이런한 불필요한 값들은  가비지 콜렉터에 의해 메모리에서 자동 해제된다. 단, 메모리에서 언제 해제될지는 예측할 수 없다.

<aside>
💡 가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다. 더 이상 사용되지 않는 메모리란 간단히 말하자면 어떤 식별자도 참조하지 않는 메모리 공간을 의미한다. 자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어로서 가비지 콜렉터를 통해 메모리 누수를 방지한다.

</aside>

## 4.7 식별자 네이밍 규칙

식별자는 다음과 같은 네이밍 규칙을 준수해야 한다.

- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함할 수 있다.
- 단, 식별자는 특수문자를 제외한 문자, 언더스코어(_), 달러 기호($)로 사작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.
- 예약어는 식별자로 사용할 수 없다.

ES5부터 식별자를 만들 때 유니코드 문자를 허용하므로 알파벳 외의 한글이나 일본어 식별자도 사용할 수 있다. 하지만 알파벳 외의 유니코드 문자로 명명된 식별자를 사용하는 것은 바람직하지 않으므로 권장하지 않는다.

다음 식별자는 명명 규칙에 위배되므로 변수 이름으로 사용할 수 없다.

```jsx
var first-name;
var 1st;
var this;
```

자바스크립트는 대소문자를 구별하므로 다음 변수는 각각 별개의 변수다.

```jsx
var fistname;
var firstName;
var FIRSTNAME;
```

변수 이름은 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현

```jsx
var x = 3;
var score = 100;
```

변수 선언에 별도의 주석이 필요하다면 변수의 존재 목적을 명확히 드러내지 못하는 것

```jsx
// 경과 시간. 단위는 날짜다.
var d;
var elapsedTimeInDays;
```

네이밍 컨벤션은 하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한눈에 구분하기 위해 규정한 명명 규칙.

```jsx
// 카멜 케이스 (camelCase)
var firstName;

// 스네이크 케이스 (snake_case)
var first_name;

// 파스칼 케이스 (PascalCase)
var FirstName;

// 헝가리안 케이스 (ttypeHungarianCase)
var strFirstName;  // type + identifier
var $lelem = document.getElementById('myId');  // DOM 노드
var observable$ = fromEvent(document, 'click');  // RxJS 옵저버블

```

일관성을 유지한다면 어떤 네이밍 컨벤션을 사용해도 좋지마 자바스크립트에서는 일반적으로 변수나 함수의 이름에는 카멜 케이스르 사용하고, 생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용.

# 5 표현식과 문

## 5.1 값

값(value)은 식(표현식expression)이 평가(evaluate)되어 생성된 결과를 말한다.

```jsx
// 10 + 20은 평가되어 숫자 값 30을 생성한다.
10 + 20;  // 30
```

모든 값은 데이터 타입을 가지며, 메모리에 2진수, 즉 비트의 나열로 저장된다. 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다. 예를 들어, 메모리에 저장된 값 0100 0001을 숫자로 해석하면 65지만 문자로 해석하면 ‘A’다.

변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름. 따라서 변수에 할당되는 것은 값이다.

```jsx
// 변수에는 10 + 20이 평가되어 생성된 숫자 값 30이 할당된다.
var sum = 10 + 20
```

변수 이름 sum이 기억하는 메모리 공간에 저장된 것은 10 + 20이 아니라 값 30이다.

## 5.2 리터럴

리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.

![KakaoTalk_20220808_162718085.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1d0636c5-7b21-4067-9b93-78caf5694895/KakaoTalk_20220808_162718085.jpg)

리터럴은 사람이 이해할 수 있는 문자(아라비아 숫자, 알파벳, 한글 등) 또는 미리 약속된 기호(’’, “”, ., [], {}, // 등) 로 표기한 코드다. 자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다. 즉, 리터럴은 값을 생성하기 위해 미리 약속한 표기법이라고 할 수 있다.

![KakaoTalk_20220808_162526364.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bb12ba43-2bc2-4086-8016-c778f9aa8dae/KakaoTalk_20220808_162526364.jpg)

## 5.3 표현식

표현식(expression)은 값으로 평가될 수 있는 문(statement)이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.

 값으로 평가될 수 있는 문은 모두 표현식

```jsx
// 리터럴 표현식
10
'Hello'

// 식별자 표현식(선언이 이미 존재한다고 가정)
sum
person.name
arr[1]

// 연산자 표현식
10 + 20
sum = 10
sum !== 10

// 함수/메서드 호출 표현식(선언이 이미 존재한다고 가정)
square()
person.getName()
```

표현식은 값으로 평가된다. 이때 표현식과 표현식이 평가된 값은 동등한 관계, 즉 동치(equivalent)다. 즉, 문법적으로 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다는 것을 의미

```jsx
 var x = 1 + 2;

// 식별자 표현식 x는 3으로 평가된다.
x + 3; // -> 6
```

+연산자는 좌항과 우항의 값을 산술 연산하는 연산자이므로 좌항과 우항에는 숫자값이 위치해야함. 이때 좌항 x는 식별자 표현식. 즉, x는 할당되어 있는 숫자 값 3으로 평가됨. 따라서 숫자 값이 위치해야할 자리에  표현식을 사용할 수 있음. 

표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어낼 수 있음

## 5.4 문

문 statement과 표현식expression을 구별하고 해서갈 수 있다면 자바스크립트 엔진의 입장에서 코드를 읽을 수 있고 실행 결과를 예측하는 데 도움이 된다.

문statement은 프로그램을 구성하는 기본 단위이자 최소 실행 단위다. 문의 집합으로 이뤄진 것이 바로 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍이다.

문은 여러 토큰으로 구성됨. 토큰이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미. 예를 들어, 키워드, 식별자, 연산자, 리터럴, 세미콜론이나 마침표 등의 특수 기호는 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소이므로 모두 토큰.

![KakaoTalk_20220808_165438889.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a3a7848c-689b-4744-8a07-cca0c3a82ad5/KakaoTalk_20220808_165438889.jpg)

문은 명령문이라고도 부른다. 즉, 문은 컴퓨터에 내리는 명령이다.

문은 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다.

```jsx
// 변수 선언문
var x;

// 할당문
x = 5;

// 함수 선언문
function foo () {}

// 조건문
if (x > 1) {console.log(x);}

// 반복문
for (var i = 0; i < 2; i++) {console.log(i);}
```

## 5.5 세미콜론과 세미콜론 자동 삽입 기능

세미콜론은 문의 종료를 나타낸다. 따라서 문을 끝낼 때는 세미콜론을 붙여야함. 단 0개 이상의 문을 중괄호로 묶은 코드 블록({…})뒤에는 세미콜론을 붙이지 않는다.

문의 끝에 붙이는 세미콜론은 생략 가능하다. 이는 자바스크립트 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능(ASI)이 암묵적으로 수행되기 때문이다.

하지만 세미콜론 자동 삽입 기능의 동작과 개발자의 예측이 일치하지 않는 경우가 간혹 있다.

```jsx
function foo () {
	return
		{}
	// ASI의 동작 결과 => return; {};
	// 개발자의 예측 => return {};
}
console.log(foo()); // undefined

var bar = function () {}
(function() {})();

// ASI의 동작 결과 => var bar = function () {}(function() {})();
// 개발자의 예측 => var bar = function () {};(function() {})();
// TypeError: (intermediate value)(...) is not function
```

## 5.6 표현식인 문과 표현식이 아닌 문

표현식은 문의 일부일 수도 있고 그자체로 문이 될 수도 있다.

```jsx
// 변수 선언문은 값으로 평가될 수 없으므로 표현식이아니다.
var x;
// 1, 2, 1 + 2, x = 1 + 2는 모두 표현식이다.
// x = 1 + 2는 표현식이면서 완전한 문이기도 하다.
x = 1 + 2;
```

문에는 표현식인 문과 표현식이 아닌 문이 있다. 표현식인 문은 값으로 평가될 수 있는 문이며, 표현식이 아닌 문은 값으로 평가될 수 없는 문을 말한다.

이를 구별하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다.

```jsx
// 표현식이 아닌 문은 값처럼 사용할 수 없다.
var foo = var x; // SyntaxError: Unexpected token var
```

위 예제의 변수 선언문은 표현식이 아닌 문이다. 다시 말해 값으로 평가될 수 없다. 따라서 변수 선언문은 값처럼 사용할 수 없다.

```jsx
// 변수 선언문은 표현식이 아닌 문이다.
var x;

// 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인문이다.
x = 100;
```

```jsx
// 표현식인 문은 값처럼 사용할 수 있다.
var foo = x = 100;
console.log(foo);  // 100
```

할당문을 값처럼 변수에 할당했다. 표현식인 문인 할당문은 할당한 값으로 평가된다.

<aside>
💡 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력한다. 이를 완료 값이라고 한다. 완료 값은 표현식의 평가 결과가 아니다. 따라서 다른 값과 같이 변수에 할당할 수 없고 참조할 수도 없다.

크롬 개발자 도구에서 표현식인 문을 실행하면 언제나 평가된 값을 반환한다.

</aside>

# 6 데이터 타입

데이터 타입은 값의 종류를 말한다. 자바스크립트의 모든 값은 데이터 타입을 갖는다. 자바스크립트(ES6)는 7개의 데이터 타입을 제공한다. 7개의 데이터 타입은 원시 타입과 객체 타입으로 분류할 수 있다.

![KakaoTalk_20220808_173744355.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7fea91a5-82b7-43fc-8c19-9eb4503160ff/KakaoTalk_20220808_173744355.jpg)

## 6.1 숫자 타입

자바스크립트는 다른 언어와 다르게 하나의 숫자 타입만이 존재한다.

ECMAScript 사양에 따르면 숫자 타입의 값은 배졍밀도 64비트 부동소수점 형식을 따른다. 즉, 모든 수를 실수로 처리하며, 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않는다.

```jsx
모두 숫자number 타입이다.
var integer = 10;  // 정수
var double = 10.12;  // 실수
var negative = -20;  // 음의 정수
```

정수, 실수, 2진수, 8진수, 16진수 리터럴은 모두 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다. 자바스크립트는 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않기 때문에 값을 참조하면 모두 10진수로 해석됨

```jsx
var binary = 0b01000001; // 2진수
var octal = 0o101;       // 8진수
var hex = 0x41;          // 16wlstn

// 표기법만 다를 뿐 모두 같은 값이다.
console.log(binary);  // 65
console.log(octal);  // 65
console.log(hex);  // 65
console.log(binary === octal);  // true
console.log(octal === hex);  // true
```

자바스크립트의 숫자 타입은 모든 수를 실수로 처리. 이는 정수로 표시된다 해도 사실은 실수라는 것을 의미한다. 따라서 정수로 표시되는 수끼리 나누더라도 실수가 나올 수 있음.

```jsx
// 숫자 타입은 모두 실수로 처리된다.
console.log(1 === 1.0); // true
console.log(4 / 2); // 2
console.log(3 / 2); // 1.5
```

숫자 타입은 추가적으로 세 가지 특별한 값도 표현할 수 있다.

- Infinity: 양의 무한대
- -Infinity: 음의 무한대
- NaN: 산술 연산 불가(not-a-number)

```jsx
// 숫자 타입의 세 가지 특별한 값
console.log(10 / 0); // Infinity
console.log(10 / -0); // -Infinity
console.log(1 * 'String'); // NaN
```

자바스크립트는 대소문자를 구별하므로 NaN을 NAN, Nan, nan과 같이 표현하면 에러 발생. 식별자로 해석함

```jsx
// 자바스크립트는 대소문자를 구분한다.
var x = nan; // ReferenceError: nan is not defined
```

## 6.2 문자열 타입

문자열 타입은 텍스트 데이터를 나타내는데 사용.

문자열은 작은따옴표(’’), 큰따옴표(””) 또는 백틱(``)으로 텍스트를 감싼다. 자바스크립트에서 가장 일반적인 표기법은 작은따옴표를 사용하는 것이다.

```jsx
// 문자열 타입
var string;
string = '문자열'; // 작은따옴표
string = "문자열"; // 큰따옴표
string = `문자열`; // 백틱(ES6)
string = '작은따옴표로 감싼 문자열 내의 "큰따옴표"는 문자열로 인식된다.';
string = "큰따옴표로 감싼 문자열 내의 '작은따옴표'는 문자열로 인식된다.";
```

다른 타입의 값과 달리 문자열을 따옴표로 감싸는 이유는 키워드나 식별자 같은 토큰과 구분하기 위해서 

```jsx
// 따옴표로 감싸지 않은 hello를 식별자로 인식한다.
var string = hello; // ReferenceError: hello is not defined
```

자바스크립트의 문자열은 원시 타입이며, 변경 불가능한 값이다. 이것은 문자열이 생성되면 그 문자열을 변경할 수 없다는 것을 의미한다.

## 6.3 템플릿 리터럴

템플릿 리터럴은 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 편리한 문자열 처리 기능을 제공한다. 템플릿 리터럴은 런타임에 일반 문자열로 변환되어 처리된다.

백틱을 사용해 표현한다.

```jsx
var template = `Template literal`;
	console.log(template);// Template literal
```

### 6.3.1 멀티라인 문자열

일반 문자열 내에서는 줄바꿈(개행)이 허용되지 않는다.

```jsx
var str = 'Hello
world.';
// SyntaxError: Invalid or unexpected token
```

따라서 일반 문자열 내에서 줄바꿈 등의 공백을 표현하려면 백슬래시(\)로 시작하는 이스케이프 시퀀스를 사용해야한다.

```jsx
var template = '<ul>\n\t<li><a href="#">Home</a></li>\n</ul>';
console.log(template);
```

일반 문자열과 달리 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 허용되며, 모든 공백도 있는 그대로 적용

```jsx
var template = `<ul>
	<li><a href="#">Home</a></li>
</ul>`;
console.log(template);
```

### 6.3.2 표현식 삽입

문자열은 문자열 연산자 +를 사용해 연결할 수 있다. +연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작. 그 외의 경우는 덧셈 연산자로 동작

```jsx
var first = 'Ung-mo';
var last = 'Lee';

// ES5: 문자열 연결
console.log('My name is ' + first + ' ' + last '.'); // My name is Ung-mo Lee.
```

템플릿 리터럴 내에서는 표현식 삽입을 통해 간단히 문자열을 삽입ㅂ할 수 있다.

```jsx
var first = 'Ung-mo';
var last = 'Lee';

// ES6: 표현식 삽입
console.log(`My name is ${first} ${last}.`);  // My name is Ung-mo Lee.
```

표현식을 삽입하려면 ${}으로 표현식을 감싼다. 이때 표현식의 평가 결과가 문자열이 아니더라도 문자열로 타입이 강제로 변환되어 삽입된다.

```jsx
console.log(`1 + 2 = ${1 + 2}`);  // 1 + 2 = 3
```

표현식 삽입은 반드시 템플릿 리터럴 내에서 사용

```jsx
console.log('1 + 2 = ${1 + 2}');  // 1 + 2 = ${1 + 2}
```

## 6.4 불리언 타입

불리언 타입의 값은 논리적 참, 거짓을 나타내는 true와 false뿐이다.

```jsx
var foo = true;
console.log(foo);  // true

foo = false;
console.log(foo);  // false
```

## 6.5 undefined 타입

undefined 타입의 값은 undefined가 유일하다.

var 키워드로 선언한 변수는 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 빈 상태로 내버려두지 않고 자바스크립트 엔진이 undefined로 초기화한다. 따라서 변수를 선언한 이후 값을 할당하지 않은 변수를 참조하면 undefined가 반환된다.

```jsx
var foo;
console.log(foo) // undefined
```

자바스크립트 엔진이 변수를 초기화하는 데 사용하는 undefined를 개발자가 의도적으로 변수에 할당한다면 undefined의 본래 취지와 어긋날뿐더러 혼란을 줄 수 있다.

undefined대신에 null을 할당해라

## 6.6 null 타입

null 타입의 값은 null이 유일하다. 자바스크립트는 대소문자를 구별하므로 null은 Null, NULL등과 다르다.

프로그래밍 언어에서 null은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용한다. 변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미다. 자바스크립트 엔진은 누구도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행. 

```jsx
var foo = 'Lee';
// 이전 참조를 제거. foo 변수는 더 이상 'Lee'를 참조하지 않는다.
// 유용해 보이지는 않는다. 변수의 스코프를 좁게 만들어 변수 자체를 재빨리 소멸시키는 편이 낫다.
foo = null;
```

함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을반환하기도 한다. 예를 들어 HTML 요소를 검색해 반환하는 document.querySelector 메서드는 조건에 부합하는 HTML 요소를 검색할 수 없는 경우 에러 대신 null을 반환.

```jsx
var element = document.querySelector('.myClass');
// HTML 문서에 myClass 클래스를 갖는 요소가 없다면 null을 반환한다.
console.log(element); // null
```

## 6.7 심벌 타입

심벌 이외의 원시 값은 리터럴을 통해 생성하지만 심벌은 Symbol 함수를 호출해 생성한다. 이때 생성된 심벌 값은 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않는 유일무이한 값이다. 따라서 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.

```jsx
// 심벌 값 생성
var key = Symbol('key');
console.log(typeof key); // symbol

// 객체 생성
var obj = {};

// 이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용한다.
obj[key] = 'value';
console.log(obj[key]); // value
```

## 6.8 객체 타입

자바스크립트는 객체 기반의 언어이며, 자바스크립트를 이루고 있는 거의 모든 것이 객체라는 것이다. 지금까지 살펴본 6가지 데이터 타입 이외의 값은 모두 객체 타입이다.

11장 “원시 값과 객체의 비교”에서 자세히 다룸

## 6.9 데이터 타입의 필요성

### 6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조

메모리에 값을 저장하려면 먼저 확보해야 할 메모리 공간의 크기를 결정해야한다.

자바스크립트 엔진은 데이터 타입에 따라 정해진 크기의 메모리 공간을 확보한다. 즉, 변수에 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정된다.

```jsx
var score = 100; 
```

위의 예제의 경우 자바스크립트 엔진은 100을 숫자 타입의 값으로 해석하고 숫자 타입의 값을 저장하기 위해 8바이트의 메모리 공간을 확보하고 100을 2진수로 저장

참조하는 경우는 식별자 score을 통해 숫자 값 100이 저장되어 있는 메모리 공간의 선두 메모리 셀의 주소를 찾아갈 수 있음. 이때 값을 참조하려면 한 번에 읽어 들여야할 메모리 공간의 크기, 즉 메모리 셀의 개수(바이트 수)를 알아야 한다. score 변수에 숫자 타입의 값이 할당되어 있으므로 자바스크립트 엔진은 숫자 타입으로 인식하여 8바이트 단위로 메모리 공간에 저장된 값을 읽어드린다.

### 6.9.2 데이터 타입에 의한 값의 해석

메모리에서 읽어 들인 2진수를 어떻게 해석? 예를 들어 0100 0001은 데이터 타입에 따라 ‘A’로 해석될 수도 65로 해석될 수도 있음

앞에서 살펴본 예제의 score변수에 할당된 값은 숫자 타입의 값이다. 따라서 score 변수를 참조하면 메모리 공간의 주소에서 읽어 들인 2진수를 숫자로 해석한다.

데이터 타입은 값의 종류를 말한다. 자바스크립트의 모든 값은 데이터 타입을 갖는다. 데이터 타입이 필요한 이유는 다음과 같다.

- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
- 메모리 에서 읽어 들인 2진수를 어떻게 해석할 지 결정하기 위해

## 6.10 동적 타이핑

### 6.10.1 동적 타입 언어와 정적 타입 언어

C나 자바 같은 정적 타입 언어는 변수르 선언할 때 변수에 할당할 수 있는 값의 종류, 즉 데이터 타입을 사전에 선언해야한다. (명시적 타입 선언)

```c
// c 번수에는 1바이트 정수 타입의 값(-128 ~ 127)만 할당할 수 있다.
char c;

// num 변수에는 4바이트 정수 타입의 값만 할당할 수 있다.
int num;
```

정적 타입 언어는 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다. 컴파일 시점에 타입 체크를 수행한다. 만약 타입 체크를 통과하지 못했다면 에러를 발생시키고 프로그램의 실행 자체를 막는다. 이를 통해 타입의 일관성을 강제함으로써 더욱 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄인다.

자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 이러한 특징을 동적 타이핑이라 하며, 자바스크립트를 정적 타입 언어와 구별하기 위해 동적 타입 언어라 한다.

현재 변수에 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정된다.

